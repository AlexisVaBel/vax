<!doctype html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <script src="vax-vendor/underscore.js" type="text/javascript"></script>
    <script src="../jquery-1.11.2.min.js" type="text/javascript"></script>
    <script src="vax-vendor/raphael.js" type="text/javascript"></script>
    <script src="vax-vendor/raphael-paragraph.js" type="text/javascript"></script>
    <script src="vax-vendor/chosen/chosen.jquery.js" type="text/javascript"></script>
    <script src="vax.js" type="text/javascript"></script>
    <script src="calcSchema.js" type="text/javascript"></script>

    <link rel="stylesheet" href="vax-vendor/chosen/chosen.min.css" type="text/css"/>
    <link rel="stylesheet" href="styles.css" type="text/css"/>
</head>
<body>
<style type="text/css">
    body {
        background: #111;
    }
    #eval {
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 1000;
    }
</style>
<div id="vax-calc" style="width: 1800px; height: 950px;"></div>

<button id="eval" type="button">Вычислить!</button>


<script type="text/javascript">
    $(function()
    {
        window.myVAX = new VAX('vax-calc', {schema: vaxCalcSchema});

        var loadedGraph = localStorage.getItem('calcGraph');
        if (loadedGraph)
        {
            myVAX.loadGraph(JSON.parse(loadedGraph));
        }

        // eval
        $('#eval').click(function()
        {
            // first we save
            var g = myVAX.serializeGraph();
            localStorage.setItem('calcGraph', g);

            // then we calc
            var trees = myVAX.composeTreesInlined();

            if (trees.length !== 1)
            {
                return alert("There should be exactly one tree!");
            }

            var root = trees[0];

            if (root.c !== "Result")
            {
                return alert("Root node should be 'Result'!");
            }

            var prompts = {};

            var walkCalc = function walk(node)
            {
                if (!node)
                {
                    return '';
                }

                switch (node.c)
                {
                    case 'Result':
                        return walk(node.links.I).toString();

                    case 'Repeat':
                        return walk(node.links.I);

                    case 'Add':
                        return walk(node.links.A) + walk(node.links.B);

                    case 'Sub':
                        return walk(node.links.A) - walk(node.links.B);

                    case 'Mul':
                        return walk(node.links.A) * walk(node.links.B);

                    case 'Div':
                        return walk(node.links.A) / walk(node.links.B);

                    case 'Number':
                        return parseFloat(node.a.V);

                    case 'String':
                        return node.a.V.toString();

                    case 'ToString':
                        return walk(node.links.I).toString();

                    case 'Concat':
                        var chunks = [];
                        for (var i = 1; i <= 4; ++i)
                        {
                            var s = walk(node.links['S' + i]);
                            if (s)
                            {
                                chunks.push(s);
                            }
                        }
                        return chunks.join('');

                    case 'Sqrt':
                        return Math.sqrt(walk(node.links.I));

                    case 'Prompt':
                        var name = node.a.Name;
                        if (prompts.hasOwnProperty(name))
                        {
                            return prompts[name];
                        }
                        else
                        {
                            var res = parseFloat(prompt('Введите параметр ' + name, '1'));
                            prompts[name] = res;
                            return res;
                        }

                    case 'If':
                        return walk(node.links.Condition) ? walk(node.links.onTrue) : walk(node.links.onFalse);

                    case 'Gt':
                        return walk(node.links.A) > walk(node.links.B);

                    case 'Eq':
                        return walk(node.links.A) === walk(node.links.B);

                    case 'Not':
                        return !walk(node.links.I);

                    case 'And':
                        return walk(node.links.A) && walk(node.links.B);

                    case 'Or':
                        return walk(node.links.A) || walk(node.links.B);

                    default:
                        throw new Error("Unsupported node component: " + node.component);
                }
            };

            alert(walkCalc(root));
        });
    });
</script>



</body>
</html>